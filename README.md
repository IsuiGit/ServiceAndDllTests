# ServiceAndDllTests

## Как с этим работать?

### ВАЖНО!
Для корректной работы **запускайте программу через командную строку с правами администратора**

### Для тестирования .dll необходимо:

1. Скачать файлы из репозитория
2. Запустить файл `main.py`
3. В открывшемся окне выбрать вкладку `DLL -> Import .dll`
4. Далее `Test cases -> Import test case`
5. После сообщений об успешной загрузке файлов, запустите проверку `DLL -> Run .dll tests`
6. Ответы о тестировании вашей библиотеки можно увидеть в окне приложения

### Для тестирования служб необходимо:

1. Скачать файлы из репозитория
2. Запустить файл `main.py`
3. В открывшемся окне выбрать вкладку `Win32 services -> Service name`
4. Далее `Test cases -> Import test case`
5. После сообщений об успешной загрузке файлов, запустите проверку `Win32 services -> Run service tests`
6. Ответы о тестировании службы можно увидеть в окне приложения

### Тест-кейсы

Для успешного выполнения проверки разработанных вами компонент, необходимо составить тест-кейсы указанных форматов. Ниже преведены общие структуры для тест-кейсов .dll и служб. Все тест-кейсы описаны в JSON формате.

#### Структура тест-кейсов для тестирования .dll

Структура файла с тест-кейсами (dll_example.json):

```
{
	"function_name": {
		"args": null (or [] if args exists),
		"iters": <int>
	},
	...
}
```
где `function_name` - имя функции из библиотеки, `args` - набор аргументов функции, `iters` - количество итераций выполнения функции

#### Структура тест-кейсов для тестирования служб
`Так как большая часть служб в Windows основаны на процессах, использущих .dll компоненты, то в рамках тестирования служб подразумевается поиск .dll компонент служб и их точечное тестирование`

Структура файла с тест-кейсами (service_example.json):

```
{
	"dll_component_name": {
		"function_name":{
			"args": null (or [] if args exists),
			"iters": <int>
		},
	}
	...
}
```
где `dll_component_name` - имя искомой .dll внутри службы `(формата name.dll)`, `function_name` - имя функции из библиотеки, `args` - набор аргументов функции, `iters` - количество итераций выполнения функции

### Updates

#### Minor 0.3 update 19.02.25:
1. Функции тестого модуля c_tools теперь запускаются через потоковую обертку модуля t_tools[threading]
2. t_tools.py - новый модуль с модифицированным классом Thread, для запуска и получения ответа потока выполнения

#### Major 1.0 update 19.02.25:
1. Новый модуль `shedule.py`: запуск и исполнение модуля `c_tools.py` через класс `Popen` библиотеки `subprocess`
	```
	...
	p = subprocess.Popen(["python", "c_tools.py", path, case], stdout=subprocess.PIPE)
	...
	```
2. Обновленные зависимости: вызов теста `.dll` библиотек по схеме `gui -> t_tools.runThread(shedule.runProcess, args=*args)`
	```
	from t_tools import runThread
	from shedule import runProcess
	...
	dllFuncTestResponse = runThread(runProcess, args=[self.dll_path, self.case_path])
	...
	```
3. Isolated Mode: все тесты запускаются в изолированном потоке, а результаты записываются в `sys.stdout`

#### Minor 1.1.2(2225) update 20.02.2025:
1. Исправлен баг: `c_tool.py not found` - установлены относительные пути поиска исполняемых скриптов

#### Minor 1.2.0(2225)a 20.02.2025
1. Доработана функция `ServiceFuncTest` - на данный момент функция получает сведения о .dll компонентах службы и выгружает их из тест-кейсов. В ответ возвращается список найденных .dll внутри `memory_maps` процесса
